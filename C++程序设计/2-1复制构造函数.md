### 2-1复制构造函数（copy constructor）
#### 1.基本概念
- 只有一个参数，即对同类对象的引用
- 形如 X::X ( X& )或 X::X(const X &),二者选一，后者能以常量对象作为参数
- 如果没有定义复制构造函数，那么编译器生成默认复制构造函数。默认的复制构造函数完成复制功能。
>     class Complex{
>           private:
>                 double real,imag;
>     }
>
>     Complex c1;//调用缺省无参构造函数
>     Complex c2(c1);//调用缺省的复制函数，将c2初始化成和c1一样
- 如果定义的自己的复制构造函数，则默认的复制构造函数不存在。（复制构造函数只能有一个）
- 不允许有形如 X::X ( X )的构造函数，必须是本类的引用，不能是本类的对象
#### 2.复制构造函数起作用的三种情况
##### 1）当用一个对象去初始化同类的另一个对象时。
>     Complex c2(c1);
>     Complex c2=c1;//与上面的等价，是初始化语句，不是赋值语句，赋值语句是去掉Complex
##### 2）如果某函数有一个参数是类A的对象，那么该函数被调用时，类A的复制构造函数将会被调用。换句话说，作为形参的对象，用复制构造函数初始化的，而且调用复制构造函数时的参数，就是调用函数时所给的实参。
>     复制构造函数用于函数形参
>     class A
>     {
>          public:
>              A(){};
>              A(A&a){//复制构造函数
>               cout<<"Copy constructor called"<<endl;
>     }
>     };
>
>     void Func(A a1){}//形参用复制构造函数初始化
>
>     int main(){
>          A a2;
>          Func(a2)//复制构造函数的参数就是a2
>          return 0;//a1的值不一定等于a2，应自己编写的复制构造函数，
>     }
> //Func函数的形参a的值在进入函数时是随机的，未必等于实参，因为复制构造函数没有做复制的工作。
##### 3）如果函数的返回值是类A的对象时，则函数返回时，A的复制构造函数被调用，换句话说，作为函数返回值的对象是用复制构造函数初始化的，而调用复制构造函数时的实参，就是return语句所返回的对象。
>     复制构造函数用于函数返回对象
>     class A
>     {
>           public:
>           int v;
>           A(int n){v=n;};
>           A(const A&a){          //复制构造函数
>               v=a.v;     //完成复制
>               cout<<"Copy constructor called"<<endl;
>     }
>     };
>
>     A Func()
>     {
>           A b(4)
>           return b;    //b就是返回值对象被初始化时复制构造函数的参数，前面已完成复制工作
>     }
>
>     int main()
>     {
>          cout<<Func().v<<endl;
>          return 0;
>      }
>
>     //输出结果：copy constructor called
>     // 4    v的值
>     //函数的返回值不一定跟return b 的 b相等，跟复制构造函数有关
>     //因为函数的返回值是用复制函数初始化的，如果没有完成复制工作，返回值的结果未必是b。
